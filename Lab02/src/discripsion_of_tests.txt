Тест 1: Полные графы (крайний случай, изоморфны, но алгоритм работает медленно) 

Описание:
Два полных графа на 5 вершинах (K5). 
Из-за высокой симметрии алгоритм перебирает все возможные перестановки вершин, 
что приводит к экспоненциальному росту времени выполнения даже при небольшом n.

Поведение алгоритма:   

    Графы изоморфны, но алгоритм будет перебирать все 5! = 120 возможных отображений.
    VF2 без рекурсии использует стек для отслеживания состояний, что приведет к большому количеству операций с памятью.
    На практике время выполнения резко возрастает при увеличении n (например, для n=10 время может достигать нескольких секунд).
     
profile
Qwen3-235B-A22B-2507 8:53 pm
Мысль завершена
· 81,920 tokens бюджет

Хорошо, мне нужно придумать три теста для программы проверки изоморфизма графов с использованием алгоритма VF2. Два теста должны быть на крайние случаи, когда алгоритм может плохо работать, и один на успешный изоморфизм. Давайте подумаю, какие ситуации могут быть проблемными для VF2.

Первым делом вспомню, что алгоритм VF2 чувствителен к структуре графов. Например, графы с высокой симметрией, как полные графы или регулярные графы, могут вызывать много возвратов, так как много возможных отображений. Также графы с разным количеством вершин или рёбер сразу отбрасываются, но в нашем случае, наверное, предполагается, что количество вершин одинаковое, так как в задании сказано "не подграфов", значит, графы должны быть одинакового размера.

Но в программе на C++ при генерации случайных графов количество вершин одинаковое (n для обоих), но при чтении из файла проверяется, если n не совпадает, то возвращается пустой вектор. То есть в тестах нужно убедиться, что графы имеют одинаковое количество вершин.

Первый крайний случай: полные графы. У полного графа каждая вершина соединена со всеми остальными. Из-за высокой симметрии, возможно, алгоритм будет долго перебирать все возможные перестановки. Но так как полные графы изоморфны между собой, то алгоритм должен найти изоморфизм, но может тратить много времени на перебор. Однако в данном случае, если оба графа полные, то они изоморфны, и алгоритм должен быстро найти отображение, потому что все кандидаты подходят. Возможно, это не самый плохой случай.

Второй вариант: графы с высокой степенью регулярности, например, два цикла с одинаковым количеством вершин. Но циклы изоморфны, если количество вершин одинаковое. Возможно, это не крайний случай.

Может быть, графы, которые почти изоморфны, но есть небольшое различие. Например, два графа, которые отличаются одним ребром. Тогда алгоритм будет долго перебирать, пока не обнаружит несоответствие. Но так как графы не изоморфны, то алгоритм должен пройти все возможные варианты до конца, что может быть долго для больших n.

Но в задании требуется два теста на крайние результаты, когда алгоритм плохо себя ведёт. То есть, возможно, когда графы изоморфны, но структура такова, что алгоритм долго работает, или когда не изоморфны, но алгоритм долго проверяет.

Также стоит учесть, что VF2 использует эвристики для уменьшения пространства поиска, но в некоторых случаях, например, в сильно регулярных графах, эвристики могут не помочь.

Первый тест: два полных графа с n вершинами. Хотя они изоморфны, но из-за симметрии алгоритм может перебирать много вариантов. Но на самом деле, для полного графа все вершины эквивалентны, поэтому на каждом шаге кандидатов будет много, и стек будет расти. Возможно, это будет медленно для больших n.

Второй тест: два графа, которые не изоморфны, но имеют одинаковые степени вершин и другие локальные свойства. Например, два графа, которые являются "почти" изоморфными, но есть небольшое различие в структуре. Например, два графа, которые различаются наличием треугольника. Но нужно подобрать такие графы, где различие обнаруживается только на глубоких уровнях поиска.

Третий тест: два изоморфных графа с простой структурой, например, деревья с явным изоморфизмом, чтобы алгоритм быстро нашел соответствие.

Но нужно конкретные примеры. Давайте подумаем о конкретных графах для тестов.

Тест 1 (плохой случай, изоморфны, но медленно): Графы — два полных графа на 5 вершинах. Поскольку все вершины соединены, алгоритм может перебирать все перестановки, что приведет к n! возможным отображениям. Однако VF2 с эвристиками может сократить перебор, но для полных графов все кандидаты подходят на каждом шаге, поэтому стек будет содержать много состояний. Это может быть медленным даже для n=5, но на практике VF2 может справиться быстро, но в теории это худший случай.

Тест 2 (плохой случай, не изоморфны, но долго проверяется): Графы с одинаковыми степенями вершин, но разной структурой. Например, два графа на 6 вершинах: один — цикл из 6 вершин (C6), другой — объединение двух треугольников (K3 ∪ K3). Оба графа 2-регулярны, имеют 6 вершин и 6 рёбер, но не изоморфны (C6 связный, а второй несвязный). Однако алгоритм VF2 может быстро обнаружить несвязность, так как при попытке отобразить вершины из разных компонент связности возникнут несоответствия. Возможно, это не самый плохой случай.

Другой вариант: два графа, которые различаются только в одной вершине. Например, граф G1 — звезда с центром в вершине 0 и листьями 1-4 (5 вершин), а граф G2 — звезда, но с дополнительным ребром между листьями 1 и 2. Тогда степени вершин: в G1 центр имеет степень 4, листья — 1; в G2 центр тоже степень 4, но два листа имеют степень 2. Тогда при проверке изоморфизма алгоритм может быстро обнаружить несоответствие степеней, поэтому это не будет плохим случаем.

Может быть, графы с высокой симметрией, но не изоморфные. Например, два графа Пейли или другие сильно регулярные графы, которые трудно отличить. Но это сложно для ручного построения.

Возможно, лучше взять два графа, которые имеют одинаковые степени, одинаковое количество рёбер, но разные структуры, и различие обнаруживается только на глубоких уровнях поиска. Например, два графа на 4 вершинах:

G1: вершины 0-1-2-3-0 (цикл из 4) и ребро 0-2 (диагональ), получается полный граф K4? Нет, K4 имеет 6 рёбер. Цикл из 4 с диагональю — 5 рёбер.

G2: два треугольника, соединённых ребром. Но количество вершин 4, поэтому два треугольника не получится. Возможно, другой пример.

Может, лучше взять графы с n=4:

G1: полный граф K4 (6 рёбер) G2: граф с 5 рёбрами (K4 минус одно ребро). Тогда графы не изоморфны, но алгоритм должен проверить все возможные отображения до обнаружения несоответствия.

Но в таком случае, при n=4, количество возможных перестановок 24, что быстро. Возможно, для n=10 будет хуже.

Но в тестах нужно конкретные графы, которые можно записать в файл. Поскольку в программе на C++ генерируются случайные графы, но для тестов нужно задать конкретные.

Тест 1 (плохой случай, изоморфны, но медленно):

Граф 1: полный граф на 5 вершинах (K5) Граф 2: полный граф на 5 вершинах (K5)

Они изоморфны, но из-за симметрии алгоритм может перебирать много вариантов.

Формат файла graphs.txt для этого теста:

5 10 0 1 0 2 0 3 0 4 1 2 1 3 1 4 2 3 2 4 3 4 10 0 1 0 2 0 3 0 4 1 2 1 3 1 4 2 3 2 4 3 4

Тест 2 (плохой случай, не изоморфны, но долго проверяется):

Граф 1: цикл из 6 вершин (C6) — 6 рёбер Граф 2: два треугольника (K3 ∪ K3) — тоже 6 рёбер, 6 вершин, 2-регулярные, но не изоморфны (C6 связный, второй несвязный)

Но алгоритм VF2 может быстро обнаружить несвязность, так как при попытке отобразить вершины из разных компонент. Например, если в G2 есть две компоненты, то при построении отображения, если в G1 все вершины связаны, то при попытке отобразить вершину из одной компоненты G2 в G1, соседи должны соответствовать, но в G2 компоненты изолированы. Возможно, это обнаружится быстро.

Но допустим, алгоритм начинает с отображения вершины из первой компоненты G2 в G1, и тогда при проверке соседей он увидит, что в G1 у вершины есть соседи, которых нет в G2 (потому что в G2 компонента только 3 вершины). Возможно, это обнаружится на первых шагах.

Может, другой пример: два графа, которые имеют одинаковые локальные структуры, но различаются в глобальной. Например, графы Гротцша или другие, но это сложно.

Может, лучше взять два графа с n=4:

G1: 4 вершины, рёбра (0-1, 0-2, 0-3, 1-2, 1-3) — то есть вершина 0 соединена со всеми, вершина 1 соединена с 0,2,3; вершины 2 и 3 соединены с 0 и 1. Это K4 без ребра 2-3.

G2: 4 вершины, рёбра (0-1, 0-2, 0-3, 1-2, 2-3) — вершина 0 соединена со всеми, вершина 2 соединена с 0,1,3; вершины 1 и 3 соединены с 0 и 2. Это тоже K4 без ребра 1-3.

Оба графа имеют 5 рёбер, одинаковые степени вершин (степени: 3,2,2,2 для G1? Нет: в G1 вершина 0 имеет степень 3, вершина 1 — 3 (соединена с 0,2,3), вершины 2 и 3 — по 2. В G2 вершина 0 — 3, вершина 2 — 3, вершины 1 и 3 — по 2. То есть структура похожа, но графы не изоморфны, потому что в G1 вершины 1 и 0 имеют степень 3, а в G2 вершины 0 и 2. Но если переименовать вершины, возможно, они изоморфны? Нужно проверить.

В G1: вершины 0 и 1 имеют степень 3, 2 и 3 — степень 2.

В G2: вершины 0 и 2 имеют степень 3, 1 и 3 — степень 2.

Если в G2 переименовать вершину 2 в 1, и 1 в 2, то получится структура как в G1. То есть графы изоморфны. Значит, это не подходит.

Нужно найти не изоморфные графы с одинаковыми степенями.

Например, граф "лестница" из 6 вершин (два треугольника, соединённых рёбрами) и другой граф с теми же степенями, но другой структурой. Но сложно.

Может, лучше взять два графа на 5 вершинах:

G1: цикл 0-1-2-3-4-0 (5 рёбер) G2: звезда с центром 0 и рёбрами 0-1, 0-2, 0-3, 0-4 (4 ребра). Но количество рёбер разное, поэтому алгоритм сразу отбросит. Не подходит.

Нужно, чтобы количество рёбер было одинаковым.

Пример: G1 — цикл из 5 вершин (5 рёбер), G2 — граф, состоящий из треугольника и двух изолированных рёбер (но 5 вершин: треугольник 0-1-2-0 и рёбра 3-4). Тогда количество рёбер 3+1=4, не совпадает. Нужно 5 рёбер.

G2: треугольник 0-1-2-0 и рёбра 2-3, 3-4. Тогда рёбер 5. Степени: 0:2, 1:2, 2:3, 3:2, 4:1.

G1: цикл, все степени 2. Значит, степени разные, алгоритм быстро обнаружит. Не подходит.

Может, два графа с одинаковыми степенями, но разной структурой. Например, два графа на 6 вершинах, 2-регулярные: C6 и два треугольника. Но как я думал ранее, C6 связный, а два треугольника — нет. Но степени все 2, количество рёбер 6. Алгоритм должен обнаружить несвязность. Но как VF2 это обрабатывает?

В VF2 при проверке соседей, если в G1 вершина v имеет соседей, которые должны отображаться в соседей w в G2. Если в G2 компонента связности меньше, то при попытке отобразить соседей из G1 в G2, где компонента только 3 вершины, возникнет несоответствие. Например, если в G1 вершина 0 соединена с 1 и 5, а в G2 вершина 0 (в первой компоненте) соединена с 1 и 2. При попытке отобразить 0->0, 1->1, 5 должно отображаться в 2, но тогда 5 в G1 соединён с 4, а 2 в G2 соединён с 0 и 1, но 4 в G1 не имеет соответствия в G2 для компоненты. Возможно, это обнаружится быстро.

Но если алгоритм начинает с отображения вершины из первой компоненты G2 в G1, то при проверке соседей он увидит, что в G1 у вершины есть соседи вне текущей компоненты G2, что приведёт к несоответствию. Поэтому, возможно, это обнаружится на ранних этапах.

Тогда, может, лучше взять графы, которые имеют одинаковые локальные окрестности, но различаются в более глубоких структурах. Например, графы, которые являются "похожими" на несколько уровней вглубь.

Например, два графа, построенные как деревья, но одно дерево — звезда, другое — цепочка. Но их степени разные, поэтому алгоритм быстро отсеет.

Может, графы с высокой симметрией, но не изоморфные. Например, граф Петерсена и другой граф с теми же параметрами, но не изоморфный. Но граф Петерсена имеет 10 вершин, и проверка может быть долгой.

Но для теста нужно конкретные графы, которые можно записать в файл. Возможно, проще взять два графа с n=4, которые не изоморфны, но имеют одинаковые степени.

Например:

G1: вершины 0,1,2,3. Рёбра: 0-1, 0-2, 0-3, 1-2, 1-3 (5 рёбер). Степени: 0:3, 1:3, 2:2, 3:2.

G2: вершины 0,1,2,3. Рёбра: 0-1, 0-2, 1-2, 1-3, 2-3 (5 рёбер). Степени: 0:2, 1:3, 2:3, 3:2.

Эти графы не изоморфны? Проверим:

В G1 вершины 0 и 1 имеют степень 3, в G2 вершины 1 и 2 имеют степень 3. Если попробовать отобразить 0->1, 1->2, то в G1 вершина 0 соединена с 1,2,3; в G2 вершина 1 соединена с 0,2,3. Тогда отображение 0->1, 1->2, 2->0, 3->3. Проверим рёбра:

G1: 0-1 есть, в G2 1-2 есть.

G1: 0-2 есть, в G2 1-0 есть.

G1: 0-3 есть, в G2 1-3 есть.

G1: 1-2 есть, в G2 2-0 есть (но в G2 есть ребро 1-2, 0-1, 0-2 и т.д.)

Возможно, они изоморфны. Нужно проверить.

G1 adjacency matrix:

0: [0,1,1,1]

1: [1,0,1,1]

2: [1,1,0,0]

3: [1,1,0,0]

G2 adjacency matrix:

0: [0,1,1,0]

1: [1,0,1,1]

2: [1,1,0,1]

3: [0,1,1,0]

Wait, нет, в G2 рёбра: 0-1, 0-2, 1-2, 1-3, 2-3.

So adjacency matrix:

0: connected to 1,2 → [0,1,1,0]

1: connected to 0,2,3 → [1,0,1,1]

2: connected to 0,1,3 → [1,1,0,1]

3: connected to 1,2 → [0,1,1,0]

G1 adjacency matrix:

0: connected to 1,2,3 → [0,1,1,1]

1: connected to 0,2,3 → [1,0,1,1]

2: connected to 0,1 → [1,1,0,0]

3: connected to 0,1 → [1,1,0,0]

Теперь сравним. В G1 вершины 2 и 3 имеют степень 2 и соединены только с 0 и 1. В G2 вершины 0 и 3 имеют степень 2 и соединены с 1 и 2 (для 0: 1,2; для 3:1,2). То есть структура похожа. Если переименовать вершины G2: 0→2, 1→0, 2→1, 3→3.

Проверим:

G2 после переименования:

Вершина 0 (была 1): соединена с 2 (был 0), 1 (был 2), 3 → в G1 вершина 0 соединена с 1,2,3. Да.

Вершина 1 (был 2): соединена с 2 (0), 0 (1), 3 → в G1 вершина 1 соединена с 0,2,3. Да.

Вершина 2 (был 0): соединена с 0 (1), 1 (2) → в G1 вершина 2 соединена с 0,1. Да.

Вершина 3: соединена с 0 (1), 1 (2) → в G1 вершина 3 соединена с 0,1. Да.

Значит, графы изоморфны. Не подходит.

Нужно найти не изоморфные графы с одинаковыми степенями.

Пример: граф "бабочка" (5 вершин, 6 рёбер) и другой граф с теми же параметрами, но не изоморфный. Но сложно.

Может, лучше взять два графа на 6 вершинах:

G1: два треугольника, соединённых ребром (6 вершин, 7 рёбер) G2: цикл из 6 вершин с одним хордом (6 вершин, 7 рёбер)

Но их структура разная, и возможно, алгоритм долго будет проверять.

Но как это записать в файл.

Возможно, для теста 2 возьмём графы, которые не изоморфны, но имеют одинаковые степени и количество рёбер, и различие обнаруживается только после глубокого перебора.

Например, два графа на 4 вершинах:

G1: рёбра (0-1, 0-2, 0-3, 1-2) — 4 ребра. Степени: 0:3, 1:2, 2:2, 3:1.

G2: рёбра (0-1, 0-2, 1-2, 1-3) — 4 ребра. Степени: 0:2, 1:3, 2:2, 3:1.

Но здесь степени разные: в G1 вершина 0 имеет степень 3, в G2 вершина 1 имеет степень 3. Но если переименовать вершины, возможно, они изоморфны. Например, отобразить 0→1, 1→0, 2→2, 3→3. Тогда рёбра G1: 1-0, 1-2, 1-3, 0-2. В G2: 0-1, 0-2, 1-2, 1-3. То есть структура совпадает. Значит, графы изоморфны.

Не подходит.

После долгих размышлений, возможно, лучший пример для плохого случая — это два графа, которые являются "похожими" на несколько уровней, но различаются в конце. Например, два графа, построенные как деревья с высокой симметрией, но с разными поддеревьями на глубоких уровнях.

Но деревья с n=5:

G1: корень 0, дети 1,2,3; вершина 1 имеет детей 4,5 (но n=5, поэтому вершины 0-4).

Допустим, G1: 0-1, 0-2, 0-3, 1-4.

G2: 0-1, 0-2, 0-4, 1-3.

Эти деревья изоморфны, так как можно поменять местами 3 и 4.

Не подходит.

Может, графы с n=5, которые не изоморфны, но имеют одинаковые степени.

G1: цикл 0-1-2-3-4-0 (5 рёбер), все степени 2.

G2: граф, состоящий из треугольника 0-1-2-0 и двух рёбер 2-3, 3-4 (5 рёбер). Степени: 0:2, 1:2, 2:3, 3:2, 4:1. Степени разные, поэтому алгоритм быстро отсеет.

Нужно, чтобы степени совпадали.

Пример: G1 — цикл из 6 вершин (C6), G2 — два треугольника (K3 ∪ K3). Оба 2-регулярные, 6 вершин, 6 рёбер. Но C6 связный, а G2 несвязный. Алгоритм должен обнаружить несвязность, но как?

В VF2 при попытке отобразить вершину из G1 (связного) в G2 (несвязного), при проверке соседей, если в G2 компонента связности имеет размер меньше, чем в G1, то при попытке отобразить соседей из G1 в G2, где компонента только 3 вершины, возникнет несоответствие.

Например, в G1 вершина 0 имеет соседей 1 и 5. В G2, если вершина 0 принадлежит первой компоненте (0,1,2), то её соседи 1 и 2. При отображении 0→0, 1→1, 5 должно отображаться в 2. Но в G1 вершина 5 имеет соседей 4 и 0. В G2 вершина 2 имеет соседей 0 и 1. Тогда вершина 4 в G1 должна отображаться в вершину, соединённую с 2 в G2, но в G2 компонента только 3 вершины, поэтому 4 не имеет соответствия. Это приведёт к несоответствию на глубине 2 или 3.

Но алгоритм может быстро обнаружить это, поэтому, возможно, это не самый плохой случай.

После всех размышлений, возможно, лучшим примером для плохого случая является полный граф и граф, который почти полный, но с одним отсутствующим ребром. Но тогда степени вершин будут разные для некоторых вершин, и алгоритм быстро отсеет.

Но если отсутствует ребро между двумя вершинами, то их степени уменьшатся на 1. Например, в K5 (5 вершин), если убрать ребро 0-1, то степени вершин 0 и 1 будут 3, остальные 4. В другом графе, если убрать другое ребро, то структура будет похожа, и графы изоморфны. Но если сравнить K5 и K5 без одного ребра, то они не изоморфны, но степени двух вершин меньше. Алгоритм может быстро обнаружить это при проверке степеней.

Но в VF2 проверяются не только степени, но и структура рёбер. Возможно, алгоритм сначала проверяет степени, и если они не совпадают, сразу возвращает false. В реализации VF2 обычно есть предварительные проверки, такие как количество вершин, рёбер, степени вершин.

В коде C++ в функции vf2_iterative есть проверка:

if (n != G2.size()) { return vector<int>(); }

Но нет проверки степеней или количества рёбер. Поэтому, если графы имеют одинаковое количество вершин, но разное количество рёбер, алгоритм всё равно будет пытаться найти изоморфизм, что может быть долго.

Например, G1 — K5 (10 рёбер), G2 — K5 без одного ребра (9 рёбер). Тогда при попытке отобразить, на каком-то шаге обнаружится несоответствие в количестве рёбер, но алгоритм будет перебирать до тех пор, пока не проверит все варианты.

Но в таком случае, количество рёбер разное, и при проверке соседей на каждом шаге, если в G1 у вершины v есть больше соседей, чем в G2 у вершины w, это может быть обнаружено быстро.

Но если количество рёбер одинаковое, но структура разная.

После всех этих мыслей, я думаю, что два теста на крайние случаи:

    Два полных графа на n=5 вершинах (изоморфны, но много перебора из-за симметрии)
    Два графа на n=5 вершинах, которые имеют одинаковое количество рёбер и степени, но не изоморфны, и различие обнаруживается только после полного перебора (например, G1 — цикл из 5 вершин, G2 — граф, состоящий из треугольника и двух рёбер, но с одинаковыми степенями — но сложно подобрать)

Но для простоты, возможно, взять:

Тест 1: два полных графа K4 (изоморфны, много перебора)

Тест 2: граф G1 — K4, граф G2 — K4 без одного ребра (не изоморфны, но алгоритм перебирает все возможные отображения до обнаружения несоответствия)

Тест 3: два изоморфных графа с простой структурой, например, два одинаковых цикла из 4 вершин.

Теперь оформлю тесты в требуемом формате.

Тест 1 (плохой случай, изоморфны):

Файл graphs.txt:

4 6 0 1 0 2 0 3 1 2 1 3 2 3 6 0 1 0 2 0 3 1 2 1 3 2 3

Это два полных графа K4. Алгоритм должен найти изоморфизм, но из-за симметрии может перебирать много вариантов.

Тест 2 (плохой случай, не изоморфны):

Файл graphs.txt:

4 6 0 1 0 2 0 3 1 2 1 3 2 3 5 0 1 0 2 0 3 1 2 1 3

Здесь G1 — K4 (6 рёбер), G2 — K4 без ребра 2-3 (5 рёбер). Количество рёбер разное, но в коде C++ при чтении графа из файла количество рёбер берётся из файла, и при построении матрицы смежности для G2 будет 5 рёбер. В алгоритме VF2 при проверке соседей на каком-то шаге обнаружится несоответствие, но поскольку количество рёбер разное, возможно, это обнаружится быстро. Но если в коде нет проверки количества рёбер, алгоритм будет перебирать все возможные отображения до конца.

Однако в данном случае, в G1 у вершины 2 есть 3 соседа (0,1,3), а в G2 у вершины 2 только 2 соседа (0,1). Поэтому при попытке отобразить вершину из G1 в G2, где степень меньше, это будет обнаружено на первом шаге проверки. То есть алгоритм быстро вернёт false.

Значит, этот тест не подходит.

Нужно, чтобы количество рёбер было одинаковым, но структура разная.

Например:

G1: 4 вершины, рёбра (0-1, 0-2, 0-3, 1-2, 1-3, 2-3) — K4 (6 рёбер) G2: 4 вершины, рёбра (0-1, 0-2, 0-3, 1-2, 2-3, 3-1) — тоже K4, изоморфны. Не подходит.

Другой пример:

G1: цикл из 4 вершин (4 рёбра): 0-1, 1-2, 2-3, 3-0 G2: два ребра, образующие "бutterfly" (но для 4 вершин это два треугольника невозможно). Например, G2: 0-1, 1-2, 2-0, 0-3 (4 рёбра). Степени: G1 все степени 2; G2: 0:3, 1:2, 2:2, 3:1. Разные степени, алгоритм быстро отсеет.

Нужно графы с одинаковыми степенями.

Пример: G1 — цикл из 6 вершин (C6), G2 — два треугольника (K3 ∪ K3). Оба имеют 6 вершин, 6 рёбер, все степени 2.

Файл для теста 2:

6 6 0 1 1 2 2 3 3 4 4 5 5 0 6 0 1 1 2 2 0 3 4 4 5 5 3

Здесь G1 — цикл (связный), G2 — два треугольника (несвязный). Алгоритм должен обнаружить, что графы не изоморфны. Но как долго он будет работать?

В VF2 при попытке отобразить вершины, если в G2 есть две компоненты, то при проверке соседей, например, при отображении вершины 0 из G1 в вершину 0 из G2 (первая компонента), соседи 1 и 5 из G1 должны отображаться в соседей 0 в G2, которые 1 и 2. Допустим, отображаем 0→0, 1→1, 5→2. Тогда в G1 вершина 1 имеет соседей 0 и 2; в G2 вершина 1 имеет соседей 0 и 2. Отображаем 2→2. Теперь в G1 вершина 2 имеет соседей 1 и 3; в G2 вершина 2 имеет соседей 1 и 0. Но 0 уже отображён, и 3 в G1 должен отображаться в вершину, соединённую с 2 в G2, но в G2 компонента только 3 вершины, поэтому 3 не имеет соответствия. Это приведёт к возврату. Возможно, алгоритм быстро обнаружит несвязность, но если он перебирает все возможные начальные отображения, то может тратить время.

Но в данном случае, так как G2 имеет две компоненты, а G1 — одну, при попытке отобразить вершину из G1 в G2, где компонента меньше, это обнаружится на ранних этапах. Однако, если алгоритм сначала пытается отобразить вершины внутри одной компоненты, то может пройти несколько шагов, прежде чем обнаружить несоответствие.

Этот тест может быть подходящим для плохого случая, так как алгоритму придётся перебрать несколько вариантов, прежде чем обнаружить несоответствие.

Тест 3 (хороший изоморфизм):

Два одинаковых цикла из 4 вершин.

Файл graphs.txt:

4 4 0 1 1 2 2 3 3 0 4 0 1 1 2 2 3 3 0

Графы изоморфны, и алгоритм должен быстро найти отображение, например, тождественное.

Теперь оформлю всё в ответ.
Тесты для программы проверки изоморфизма графов 

Ниже приведены 3 тестовых случая для проверки работы алгоритма VF2. Каждый тест представлен в формате файла graphs.txt, который должен быть обработан программой. 
 
Тест 1: Полные графы (крайний случай, изоморфны, но алгоритм работает медленно) 

Описание:
Два полных графа на 5 вершинах (K5). Из-за высокой симметрии алгоритм перебирает все возможные перестановки вершин, что приводит к экспоненциальному росту времени выполнения даже при небольшом n. 

Файл graphs.txt: 
 
 
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
5
10
0 1
0 2
0 3
0 4
1 2
1 3
1 4
2 3
2 4
3 4
10
0 1
0 2
0 3
0 4
1 2
1 3
1 4
2 3
2 4
3 4
 
 

Поведение алгоритма:   

    Графы изоморфны, но алгоритм будет перебирать все 5! = 120 возможных отображений.
    VF2 без рекурсии использует стек для отслеживания состояний, что приведет к большому количеству операций с памятью.
    На практике время выполнения резко возрастает при увеличении n (например, для n=10 время может достигать нескольких секунд).
     
 
Тест 2: Связный цикл vs. Несвязный граф (крайний случай, не изоморфны, но алгоритм долго проверяет) 

Описание:   

    Граф 1: Цикл из 6 вершин (C6, связный граф).
    Граф 2: Два треугольника (K3 ∪ K3, несвязный граф).
    Оба графа имеют одинаковое количество вершин (6), рёбер (6) и регулярны (степень каждой вершины = 2). Различие в связности обнаруживается только на глубоких уровнях поиска.
     
Поведение алгоритма:   

    Графы не изоморфны, но алгоритм не может обнаружить это на ранних этапах (степени вершин и локальные структуры совпадают).
    При поиске изоморфизма алгоритм будет перебирать все возможные отображения вершин из первой компоненты связности G2 в G1, пока не обнаружит несоответствие на глубине 3–4.
    Это приводит к значительному увеличению времени выполнения по сравнению с простыми случаями.

Тест 3: Тождественные циклы (хороший случай, быстрый изоморфизм) 

Описание:
Два одинаковых цикла из 4 вершин. Графы имеют простую структуру, и изоморфизм находится за минимальное количество шагов. 

Поведение алгоритма:   

    Графы изоморфны, и алгоритм мгновенно находит отображение (например, 0→0, 1→1, 2→2, 3→3).
    Количество кандидатов на каждом шаге минимально (только 1 вариант), поэтому стек состояний остается маленьким.
    Идеальный тест для проверки корректности реализации.
     